{
  "version": 3,
  "sources": ["../../three/examples/jsm/utils/BufferGeometryUtils.js", "../../three/examples/jsm/modifiers/SimplifyModifier.js"],
  "sourcesContent": ["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n// Creates a new, non-indexed geometry with smooth normals everywhere except faces that meet at\n// an angle greater than the crease angle.\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vertors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\tconst resultGeometry = geometry.toNonIndexed();\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().' ); // @deprecated, r151\n\treturn mergeGeometries( geometries, useGroups );\n\n}\n\nfunction mergeBufferAttributes( attributes ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().' ); // @deprecated, r151\n\treturn mergeAttributes( attributes );\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeBufferGeometries,\n\tmergeAttributes,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n", "import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tVector3\n} from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\n\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nconst _cb = new Vector3(), _ab = new Vector3();\n\nclass SimplifyModifier {\n\n\tmodify( geometry, count ) {\n\n\t\tgeometry = geometry.clone();\n\t\tconst attributes = geometry.attributes;\n\n\t\t// this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tif ( name !== 'position' ) geometry.deleteAttribute( name );\n\n\t\t}\n\n\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\n\n\t\t//\n\t\t// put data of original geometry in different data structures\n\t\t//\n\n\t\tconst vertices = [];\n\t\tconst faces = [];\n\n\t\t// add vertices\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\tconst v = new Vector3().fromBufferAttribute( positionAttribute, i );\n\n\t\t\tconst vertex = new Vertex( v );\n\t\t\tvertices.push( vertex );\n\n\t\t}\n\n\t\t// add faces\n\n\t\tlet index = geometry.getIndex();\n\n\t\tif ( index !== null ) {\n\n\t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\t\tconst a = i;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\n\t\t\t\tfaces.push( triangle );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute all edge collapse costs\n\n\t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\n\n\t\t}\n\n\t\tlet nextVertex;\n\n\t\tlet z = count;\n\n\t\twhile ( z -- ) {\n\n\t\t\tnextVertex = minimumCostEdge( vertices );\n\n\t\t\tif ( ! nextVertex ) {\n\n\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\n\n\t\t}\n\n\t\t//\n\n\t\tconst simplifiedGeometry = new BufferGeometry();\n\t\tconst position = [];\n\n\t\tindex = [];\n\n\t\t//\n\n\t\tfor ( let i = 0; i < vertices.length; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ].position;\n\t\t\tposition.push( vertex.x, vertex.y, vertex.z );\n\t\t\t// cache final index to GREATLY speed up faces reconstruction\n\t\t\tvertices[ i ].id = i;\n\n\t\t}\n\n\t\t//\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\t\t\tindex.push( face.v1.id, face.v2.id, face.v3.id );\n\n\t\t}\n\n\t\t//\n\n\t\tsimplifiedGeometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\t\tsimplifiedGeometry.setIndex( index );\n\n\t\treturn simplifiedGeometry;\n\n\t}\n\n}\n\nfunction pushIfUnique( array, object ) {\n\n\tif ( array.indexOf( object ) === - 1 ) array.push( object );\n\n}\n\nfunction removeFromArray( array, object ) {\n\n\tconst k = array.indexOf( object );\n\tif ( k > - 1 ) array.splice( k, 1 );\n\n}\n\nfunction computeEdgeCollapseCost( u, v ) {\n\n\t// if we collapse edge uv by moving u to v then how\n\t// much different will the model change, i.e. the \"error\".\n\n\tconst edgelength = v.position.distanceTo( u.position );\n\tlet curvature = 0;\n\n\tconst sideFaces = [];\n\n\t// find the \"sides\" triangles that are on the edge uv\n\tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\n\n\t\tconst face = u.faces[ i ];\n\n\t\tif ( face.hasVertex( v ) ) {\n\n\t\t\tsideFaces.push( face );\n\n\t\t}\n\n\t}\n\n\t// use the triangle facing most away from the sides\n\t// to determine our curvature term\n\tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\n\n\t\tlet minCurvature = 1;\n\t\tconst face = u.faces[ i ];\n\n\t\tfor ( let j = 0; j < sideFaces.length; j ++ ) {\n\n\t\t\tconst sideFace = sideFaces[ j ];\n\t\t\t// use dot product of face normals.\n\t\t\tconst dotProd = face.normal.dot( sideFace.normal );\n\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\n\n\t\t}\n\n\t\tcurvature = Math.max( curvature, minCurvature );\n\n\t}\n\n\t// crude approach in attempt to preserve borders\n\t// though it seems not to be totally correct\n\tconst borders = 0;\n\n\tif ( sideFaces.length < 2 ) {\n\n\t\t// we add some arbitrary cost for borders,\n\t\t// borders += 10;\n\t\tcurvature = 1;\n\n\t}\n\n\tconst amt = edgelength * curvature + borders;\n\n\treturn amt;\n\n}\n\nfunction computeEdgeCostAtVertex( v ) {\n\n\t// compute the edge collapse cost for all edges that start\n\t// from vertex v.  Since we are only interested in reducing\n\t// the object by selecting the min cost edge at each step, we\n\t// only cache the cost of the least cost edge at this vertex\n\t// (in member variable collapse) as well as the value of the\n\t// cost (in member variable collapseCost).\n\n\tif ( v.neighbors.length === 0 ) {\n\n\t\t// collapse if no neighbors.\n\t\tv.collapseNeighbor = null;\n\t\tv.collapseCost = - 0.01;\n\n\t\treturn;\n\n\t}\n\n\tv.collapseCost = 100000;\n\tv.collapseNeighbor = null;\n\n\t// search all neighboring edges for \"least cost\" edge\n\tfor ( let i = 0; i < v.neighbors.length; i ++ ) {\n\n\t\tconst collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\n\n\t\tif ( ! v.collapseNeighbor ) {\n\n\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\tv.collapseCost = collapseCost;\n\t\t\tv.minCost = collapseCost;\n\t\t\tv.totalCost = 0;\n\t\t\tv.costCount = 0;\n\n\t\t}\n\n\t\tv.costCount ++;\n\t\tv.totalCost += collapseCost;\n\n\t\tif ( collapseCost < v.minCost ) {\n\n\t\t\tv.collapseNeighbor = v.neighbors[ i ];\n\t\t\tv.minCost = collapseCost;\n\n\t\t}\n\n\t}\n\n\t// we average the cost of collapsing at this vertex\n\tv.collapseCost = v.totalCost / v.costCount;\n\t// v.collapseCost = v.minCost;\n\n}\n\nfunction removeVertex( v, vertices ) {\n\n\tconsole.assert( v.faces.length === 0 );\n\n\twhile ( v.neighbors.length ) {\n\n\t\tconst n = v.neighbors.pop();\n\t\tremoveFromArray( n.neighbors, v );\n\n\t}\n\n\tremoveFromArray( vertices, v );\n\n}\n\nfunction removeFace( f, faces ) {\n\n\tremoveFromArray( faces, f );\n\n\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\n\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\n\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\n\n\t// TODO optimize this!\n\tconst vs = [ f.v1, f.v2, f.v3 ];\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst v1 = vs[ i ];\n\t\tconst v2 = vs[ ( i + 1 ) % 3 ];\n\n\t\tif ( ! v1 || ! v2 ) continue;\n\n\t\tv1.removeIfNonNeighbor( v2 );\n\t\tv2.removeIfNonNeighbor( v1 );\n\n\t}\n\n}\n\nfunction collapse( vertices, faces, u, v ) { // u and v are pointers to vertices of an edge\n\n\t// Collapse the edge uv by moving vertex u onto v\n\n\tif ( ! v ) {\n\n\t\t// u is a vertex all by itself so just delete it..\n\t\tremoveVertex( u, vertices );\n\t\treturn;\n\n\t}\n\n\tconst tmpVertices = [];\n\n\tfor ( let i = 0; i < u.neighbors.length; i ++ ) {\n\n\t\ttmpVertices.push( u.neighbors[ i ] );\n\n\t}\n\n\n\t// delete triangles on edge uv:\n\tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\tif ( u.faces[ i ] && u.faces[ i ].hasVertex( v ) ) {\n\n\t\t\tremoveFace( u.faces[ i ], faces );\n\n\t\t}\n\n\t}\n\n\t// update remaining triangles to have v instead of u\n\tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\n\n\t\tu.faces[ i ].replaceVertex( u, v );\n\n\t}\n\n\n\tremoveVertex( u, vertices );\n\n\t// recompute the edge collapse costs in neighborhood\n\tfor ( let i = 0; i < tmpVertices.length; i ++ ) {\n\n\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\n\n\t}\n\n}\n\n\n\nfunction minimumCostEdge( vertices ) {\n\n\t// O(n * n) approach. TODO optimize this\n\n\tlet least = vertices[ 0 ];\n\n\tfor ( let i = 0; i < vertices.length; i ++ ) {\n\n\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\n\n\t\t\tleast = vertices[ i ];\n\n\t\t}\n\n\t}\n\n\treturn least;\n\n}\n\n// we use a triangle class to represent structure of face slightly differently\n\nclass Triangle {\n\n\tconstructor( v1, v2, v3, a, b, c ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t\tthis.normal = new Vector3();\n\n\t\tthis.computeNormal();\n\n\t\tv1.faces.push( this );\n\t\tv1.addUniqueNeighbor( v2 );\n\t\tv1.addUniqueNeighbor( v3 );\n\n\t\tv2.faces.push( this );\n\t\tv2.addUniqueNeighbor( v1 );\n\t\tv2.addUniqueNeighbor( v3 );\n\n\n\t\tv3.faces.push( this );\n\t\tv3.addUniqueNeighbor( v1 );\n\t\tv3.addUniqueNeighbor( v2 );\n\n\t}\n\n\tcomputeNormal() {\n\n\t\tconst vA = this.v1.position;\n\t\tconst vB = this.v2.position;\n\t\tconst vC = this.v3.position;\n\n\t\t_cb.subVectors( vC, vB );\n\t\t_ab.subVectors( vA, vB );\n\t\t_cb.cross( _ab ).normalize();\n\n\t\tthis.normal.copy( _cb );\n\n\t}\n\n\thasVertex( v ) {\n\n\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\n\n\t}\n\n\treplaceVertex( oldv, newv ) {\n\n\t\tif ( oldv === this.v1 ) this.v1 = newv;\n\t\telse if ( oldv === this.v2 ) this.v2 = newv;\n\t\telse if ( oldv === this.v3 ) this.v3 = newv;\n\n\t\tremoveFromArray( oldv.faces, this );\n\t\tnewv.faces.push( this );\n\n\n\t\toldv.removeIfNonNeighbor( this.v1 );\n\t\tthis.v1.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v2 );\n\t\tthis.v2.removeIfNonNeighbor( oldv );\n\n\t\toldv.removeIfNonNeighbor( this.v3 );\n\t\tthis.v3.removeIfNonNeighbor( oldv );\n\n\t\tthis.v1.addUniqueNeighbor( this.v2 );\n\t\tthis.v1.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v2.addUniqueNeighbor( this.v1 );\n\t\tthis.v2.addUniqueNeighbor( this.v3 );\n\n\t\tthis.v3.addUniqueNeighbor( this.v1 );\n\t\tthis.v3.addUniqueNeighbor( this.v2 );\n\n\t\tthis.computeNormal();\n\n\t}\n\n}\n\nclass Vertex {\n\n\tconstructor( v ) {\n\n\t\tthis.position = v;\n\n\t\tthis.id = - 1; // external use position in vertices list (for e.g. face generation)\n\n\t\tthis.faces = []; // faces vertex is connected\n\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n\t\t// these will be computed in computeEdgeCostAtVertex()\n\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\t\tthis.collapseNeighbor = null; // best candinate for collapsing\n\n\t}\n\n\taddUniqueNeighbor( vertex ) {\n\n\t\tpushIfUnique( this.neighbors, vertex );\n\n\t}\n\n\tremoveIfNonNeighbor( n ) {\n\n\t\tconst neighbors = this.neighbors;\n\t\tconst faces = this.faces;\n\n\t\tconst offset = neighbors.indexOf( n );\n\n\t\tif ( offset === - 1 ) return;\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\n\n\t\t}\n\n\t\tneighbors.splice( offset, 1 );\n\n\t}\n\n}\n\nexport { SimplifyModifier };\n"],
  "mappings": "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",
  "names": []
}
